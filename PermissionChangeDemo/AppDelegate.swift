import UIKit
import RealmSwift

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

    // Define some arbitrary test users that are used to share data between each other
    let user1 = Credentials(username: "user1", password: "user1", email: "user1@123.nl")
    let user2 = Credentials(username: "user2", password: "user2", email: "user2@123.nl")
    
    var currentUser: User? {
        return (try! Realm()).objects(User.self).first // Only one User object exists per user's Realm
    }
    
    // To be able to test the SyncPermissionOffer and response in a single run, the register status of user1 and user2 are stored in UserDefaults. 
    // UserDefaults are used since it is not (yet) possible to determine whether a user is already registered using the ROS API.
    // The values in UserDefaults, however, are only correct when the first run of the app starts with empty UserDefaults and user1 and user2 have not yet been created in ROS
    var user1created: Bool {
        get {
            return UserDefaults.standard.bool(forKey: "user1Available")
        }
        set(user) {
            UserDefaults.standard.set(user, forKey: "user1Available")
        }
    }

    var user2created: Bool {
        get {
            return UserDefaults.standard.bool(forKey: "user2Available")
        }
        set(user) {
            UserDefaults.standard.set(user, forKey: "user2Available")
        }
    }

    // NoticationTokens
    var shareOfferNotificationToken: NotificationToken!
    var shareResponseNotificationToken: NotificationToken!
    
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {

        self.window?.rootViewController = UIViewController()
        self.window?.makeKeyAndVisible()
        
        // If a user was already logged in, it will be loged out
        if let realmUser = SyncUser.current {
            realmUser.logOut()
        }

        // Based on the UserDefaults a user will be logged in or registered
        print(String(format: "%@ user 1 \n%@ user 2", user1created ? "Login" : "Register", user2created ? "Login" : "Register"))
        
        //
        // Authenticate user1
        //
        
        Authenticate.authenticate(with: user1, register: !user1created) { error in
            guard error == nil else {
                if case AppError.userAlreadyCreated(_) = error! {
                    print("Error: this demo app assumes empty UserDefaults and an empty Realm Object Server at start. Probably user1 and or user2 were already registered.")
                    print("Please empty UserDefaults/remove app and remove user1 and/or user2 from Realm ObjectServer.")
                } else {
                    print(error!);
                }
                return
            }
            self.user1created = true
            
            //
            // Share Realm of user1 with user2
            //
            
            // Create share token from user1
            let syncConfig = Realm.Configuration.defaultConfiguration.syncConfiguration!
            let shareOffer = SyncPermissionOffer(realmURL: syncConfig.realmURL.absoluteString, expiresAt: nil, mayRead: true, mayWrite: true, mayManage: false)
            
            // Save PermissionOffer to user's management Realm
            let managementRealm = try! syncConfig.user.managementRealm()
            try! managementRealm.write { managementRealm.add(shareOffer) }
            
            print("\nShare offer ID: \(shareOffer.id)\n")
            
            let offerResults = managementRealm.objects(SyncPermissionOffer.self).filter("id = %@", shareOffer.id)
            self.shareOfferNotificationToken = offerResults.addNotificationBlock { changes in
                guard case let offer = offerResults.first,
                    offer?.status == .success,
                    let token = offer?.token else { print("Error creating token"); return }
                
                // Normally, this token should be shared using e-mail or other method
                print("\nPermissionOffer generated a token: \(token)\n")
                print("This token will be shared with user2")

                SyncUser.current!.logOut() // Logout user1 so that user2 is able to accept the PermissionOffer token
                
                //
                // Authenticate user2
                //
                
                Authenticate.authenticate(with: self.user2, register: !self.user2created) { error in
                    guard error == nil else { print("\n\(error!)\n"); return }
                    self.user2created = true
                    
                    //
                    // Process token generated by SyncPermissionOffer of user1
                    //
                    
                    let managementRealm = try! SyncUser.current!.managementRealm()
                    let response = SyncPermissionOfferResponse(token: token) //Save PermissionOfferResponse to management Realm of user2
                    
                    try! managementRealm.write { managementRealm.add(response) }
                    
                    // Wait for server to process
                    let responseResults = managementRealm.objects(SyncPermissionOfferResponse.self).filter("id = %@", response.id)
                    self.shareResponseNotificationToken = responseResults.addNotificationBlock { changes in // acceptShareNotificationToken
                        
                        guard case let response = responseResults.first,
                            response?.status == .success,
                            let sharedRealmURL = response?.realmUrl else {
                                return
                        }
                        
                        print("\nPermissionOfferResponse successful and generated realm URL:")
                        print(sharedRealmURL)
                        
                        //
                        // Save share server path (i.e. user ID of shared Realm owner) in custom User object
                        //
                        let components = sharedRealmURL.components(separatedBy: "/")
                        try! Realm().write {
                            self.currentUser!.sharedServerPath = components[3]
                        }
                        
                        // Shared realm url that is stored in cursom User object should be the same as the one that is provided by SyncPermissionOfferResponse
                        guard sharedRealmURL == self.currentUser!.realmUrl!.absoluteString else { fatalError() }
                        
                        //
                        // Open shared Realm
                        //
                        print("\nIt appears that a shared realm can be opened when a PermissionOffereResponse for this Realm has been processed once. When a new PermissionOffereResponse has been added to the user's management Realm, an assertion error occurs: ")
                        
                        ////////////////////////////////////////////////////////////////////////////
                        //
                        // PROBLEM HERE:
                        // It appears that a shared realm can be opened when a PermissionOffereResponse for this Realm has been processed once. When a new PermissionOffereResponse has been added to the user's management Realm, an assertion error occurs at the statement below
                        //
                        ////////////////////////////////////////////////////////////////////////////
                        
                        let sharedRealm = try! Realm(configuration: self.currentUser!.sharedRealmConfiguration!)
                        
                        ////////////////////////////////////////////////////////////////////////////
                        //
                        // PROBLEM HERE:
                        // When a succesfully shared realm path is opened, the corresponding Realm seems to be empty.
                        // How is that possible????
                        //
                        ////////////////////////////////////////////////////////////////////////////
                        print("\n****\nRetrieve dogs of user1:")
                        let sharedDogs = sharedRealm.objects(Dog.self)
                        print("Number of dogs: \(sharedDogs.count)")
                        print("\nWhy is the shared Realm empty (i.e. the of dogs zero)?????? \n****\n")
                        
                    }
                }
            }
        }
        return true
    }
    
    
    func applicationWillResignActive(_ application: UIApplication) {
        // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.
    }

    func applicationDidEnterBackground(_ application: UIApplication) {
        // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
    }

    func applicationWillEnterForeground(_ application: UIApplication) {
        // Called as part of the transition from the background to the active state; here you can undo many of the changes made on entering the background.
    }

    func applicationDidBecomeActive(_ application: UIApplication) {
        // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
    }

    func applicationWillTerminate(_ application: UIApplication) {
        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
    }


}

